#!/usr/bin/env python
PACKAGE = "phidgets"

from dynamic_reconfigure.parameter_generator_catkin import *

gen = ParameterGenerator()

algorithm = gen.enum([gen.const("None", int_t, 0, "No AHRS algorithm is used"),
                      gen.const("AHRS", int_t, 1, "AHRS algorithm, incorporating magnetometer data for yaw correction"),
                      gen.const("IMU",  int_t, 2, "IMU algorithm, using gyro and accelerometer, but not magnetometer")],
                      "Controls the AHRS algorithm")

gen.add("frame_id",    str_t,    0, "The header frame ID to use when publishing messages",  "imu_link")
gen.add("use_orientation",    bool_t,    0, "Use the phidget spatials onboard orientation estimation",  True)
gen.add("spatial_algorithm", int_t, 0, "Name of the spatial algorithm used for orientation estimation, only used if use_orientation is set to true", 1, 0, 2, edit_method=algorithm)
gen.add("ahrs_angular_velocity_threshold", double_t, 0, "Parameter for AHRS orientation estimation, only used if use_orientation is set to true", .5, 0,   1)
gen.add("ahrs_angular_velocity_delta_threshold", double_t, 0, "Parameter for AHRS orientation estimation, only used if use_orientation is set to true", .5, 0,   1)
gen.add("ahrs_acceleration_threshold", double_t, 0, "Parameter for AHRS orientation estimation, only used if use_orientation is set to true", .5, 0,   1)
gen.add("ahrs_mag_time", double_t, 0, "Parameter for AHRS orientation estimation, only used if use_orientation is set to true", .5, 0,   1)
gen.add("ahrs_accel_time", double_t, 0, "Parameter for AHRS orientation estimation, only used if use_orientation is set to true", .5, 0,   1)
gen.add("ahrs_bias_time", double_t, 0, "Parameter for AHRS orientation estimation, only used if use_orientation is set to true", .5, 0,   1)
gen.add("algorithm_magnetometer_gain", double_t, 0, "Gain of magnetometer in orientation estimation algorithm, only used if use_orientation is set to true", 0.005, 0,   1)
gen.add("heating_enabled",   bool_t,   0, "Use the internal heating element",  True)
gen.add("linear_acceleration_stdev", double_t, 0, "The standard deviation to use for the linear acceleration when publishing the message (ug)", 280, 0,   1)
gen.add("angular_velocity_stdev", double_t, 0, "The standard deviation to use for the angular velocity when publishing the message (deg/s)", 0.095, 0,   1)
gen.add("magnetic_field_stdev", double_t, 0, "The standard deviation to use for the magnetic field when publishing the message (milligauss)", 1.1, 0,   1)
gen.add("time_resynchronization_interval_ms",    int_t,    0, "The number of milliseconds to wait between resynchronizing the time on the Phidgets spatial with the local time. Larger values have less 'jumps', but will have more timestamp drift. Setting this to 0 disables resynchronization", 5000,  0, 100)
gen.add("spatial_data_rate",    double_t,    0, "The number of milliseconds between acquisitions of data on the device", 4,  1, 1000)
gen.add("temperature_data_rate",    double_t,    0, "The number of milliseconds between acquisitions of data on the device", 4,  0.017, 100.0)
gen.add("callback_delta_epsilon_ms",    int_t,    0, "The number of milliseconds epsilon allowed between callbacks when attempting to resynchronize the time. If this is set to 1, then a difference of data_interval_ms plus or minus 1 millisecond will be considered viable for resynchronization. Higher values give the code more leeway to resynchronize, at the cost of potentially getting bad resynchronizations sometimes. Lower values can give better results, but can also result in never resynchronizing. Must be less than data_interval_ms", 1,  0, 100)
gen.add("publish_rate",    int_t,    0, "How often the driver will publish data on the ROS topic. If 0 (the default), it will publish every time there is an update from the device (so at the data_interval_ms). If positive, it will publish the data at that rate regardless of the acquisition interval.", 8,  0, 100)
gen.add("cc_mag_field", double_t, 0, "Ambient magnetic field calibration value; see device's user guide for information on how to calibrate", 1.1, 0,   1)
gen.add("cc_offset0", double_t, 0, "Calibration offset value 0; see device's user guide for information on how to calibrate", 1.1, 0,   1)
gen.add("cc_offset1", double_t, 0, "Calibration offset value 1; see device's user guide for information on how to calibrate", 1.1, 0,   1)
gen.add("cc_offset2", double_t, 0, "Calibration offset value 2; see device's user guide for information on how to calibrate", 1.1, 0,   1)
gen.add("cc_gain0", double_t, 0, "Gain offset value 0; see device's user guide for information on how to calibrate", 1.1, 0,   1)
gen.add("cc_gain1", double_t, 0, "Gain offset value 1; see device's user guide for information on how to calibrate", 1.1, 0,   1)
gen.add("cc_gain2", double_t, 0, "Gain offset value 2; see device's user guide for information on how to calibrate", 1.1, 0,   1)
gen.add("cc_t0", double_t, 0, "T offset value 0; see device's user guide for information on how to calibrate", 1.1, 0,   1)
gen.add("cc_t1", double_t, 0, "T offset value 1; see device's user guide for information on how to calibrate", 1.1, 0,   1)
gen.add("cc_t2", double_t, 0, "T offset value 2; see device's user guide for information on how to calibrate", 1.1, 0,   1)
gen.add("cc_t3", double_t, 0, "T offset value 3; see device's user guide for information on how to calibrate", 1.1, 0,   1)
gen.add("cc_t4", double_t, 0, "T offset value 4; see device's user guide for information on how to calibrate", 1.1, 0,   1)
gen.add("cc_t5", double_t, 0, "T offset value 5; see device's user guide for information on how to calibrate", 1.1, 0,   1)

exit(gen.generate(PACKAGE, "phidgets", "Spatial"))